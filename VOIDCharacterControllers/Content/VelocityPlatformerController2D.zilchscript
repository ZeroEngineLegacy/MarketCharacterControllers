/************************************************************************************************************/
/* Copyright 2016 DigiPen, All Rights Reserved                                                              */
/* Last Update: 12/13/2016                                                                                  */
/* Author: Zero Engine Team                                                                                 */
/* Last updated by: Arend Danielek                                                                          */
/* Class: VelocityPlatformerController2D                                                                      */
/* Brief: Implements a basic velocity based 2D dynamic side view platformer controller.                     */
/************************************************************************************************************/

class VelocityPlatformerController2D : ZilchComponent
{
  [Dependency]
  var RigidBody : RigidBody = null;
  
  [Dependency]
  var GravityEffect : GravityEffect = null;
  
  [Dependency]
  var GroundDetection2D : GroundDetection2D = null;
  
  [Dependency]
  var KeyboardInterpreter2D : KeyboardInterpreter2D = null;
  
  //Velocity for side to side movement on ground
  [Property]
  var MoveSpeed : Real = 5.0;
  
  //Multiplier for MoveVelocity when sprinting
  [Property]
  var SprintModifier : Real = 2.0;
  
  //Force to be applied opposite of WorldUp when Jumping
  [Property]
  var JumpVelocity : Real = 3.0;
  
  [Property]
  var MaxGroundSpeed : Real = 25;
  
  //Maxium number of jumps before the player must land again
  [Property]
  var MaxJumpCount : Integer = 2;
  
  //Current number of jumps used since last on ground
  var JumpCount : Integer = 0;
  
  var VelocityApplied : Integer = 0;
  
  function Initialize(init : CogInitializer)
  {
    Zero.Connect(this.Space, Events.LogicUpdate, this.OnLogicUpdate);
    Zero.Connect(this.Space, Events.PhysicsUpdateFinished, this.OnPhysicsUpdateFinished);
    Zero.Connect(this.Owner, Events.CharMoveEvent2D, this.OnCharMoveEvent2D);
  }
  
  function OnLogicUpdate(event : UpdateEvent)
  {
    // If the character is on a walkable surface clamp the current velocity to MaxGroundSpeed
    if (this.GroundDetection2D.IsOnGround || this.GroundDetection2D.IsPartiallyOnGround)
    {
      var velLenSq = Math.LengthSq(this.RigidBody.Velocity);
      
      if (velLenSq > this.MaxGroundSpeed * this.MaxGroundSpeed)
      {
        // Normalize and scale
        this.RigidBody.Velocity /= Math.Sqrt(velLenSq);
        this.RigidBody.Velocity *= this.MaxGroundSpeed;
      }
    }
  }
  
  function OnPhysicsUpdateFinished(event : ObjectEvent)
  {
    if (this.VelocityApplied != 0)
    {
      --this.VelocityApplied;
    }
  }
  
  function OnCharMoveEvent2D(event : CharMoveEvent2D)
  {
    if (event.JumpKeyPressed)
    {
      // If the character IsOnGround this is the first jump
      if (this.GroundDetection2D.IsOnGround)
      {
        this.JumpCount = 1;
        this.Jump();
      }
      // If the character is not on ground but still has jumps left let it jump
      else if (this.JumpCount < this.MaxJumpCount)
      {
        this.JumpCount += 1;
        this.Jump();
      }
    }
    // If the player is partially on ground
    else if (this.GroundDetection2D.IsOnGround || this.GroundDetection2D.IsPartiallyOnGround)
    {
      if (this.VelocityApplied != 0)
      {
        // Return until our velocity (from jump) has been applied
        return;
      }
      
      // The movement velocity should be applied parallel to walkable surface.
      // To do this we rotate the surface normal by 90 or -90 degrees to get
      // a direction for the velocity.
      var dir = Real3();
      var angle = 0.0;
      
      if (event.MoveDir == -1)
      {
        angle = -Math.Pi * 0.5;
        dir = Math.RotateVector(this.GroundDetection2D.GroundNormal, Real3(0,0,1), angle);
      }
      else if (event.MoveDir == 1)
      {
        angle = Math.Pi * 0.5;
        dir = Math.RotateVector(this.GroundDetection2D.GroundNormal, Real3(0,0,1), angle);
      }
      
      var newVel = dir * this.MoveSpeed;
      
      // Check if sprint button down
      if (event.SprintKeyDown)
      {
        newVel = newVel * this.SprintModifier;
      }
      
      this.RigidBody.Velocity = newVel;
    }
  }
  
  function Jump()
  {
    var vel = this.RigidBody.Velocity;
    vel.Y = this.JumpVelocity;
    this.RigidBody.Velocity = vel;
    
    // Wait until the next physics update so we
    // know the velocity has been applied
    this.VelocityApplied = 2;
  }
}
