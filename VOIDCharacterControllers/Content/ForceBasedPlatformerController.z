/************************************************************************************************************/
/* Copyright 2016 DigiPen, All Rights Reserved                                                              */
/* Last Update: 1/3/2017                                                                                    */
/* Author: Zero Engine Team                                                                                 */
/* Last updated by: Arend Danielek                                                                          */
/* Class: ForceBasedPlatformerController                                                                    */
/* Brief: Implements a basic force based 2D dynamic side view platformer controller.                        */
/************************************************************************************************************/

class ForceBasedPlatformerController : ZilchComponent
{
    [Dependency]
    var GroundDetection : GroundDetection;
    
    [Dependency]
    var RigidBody : RigidBody;
    
    [Dependency]
    var GravityEffect : GravityEffect;
    
    [Property]
    var MoveForce : Real = 10;
    
    //Multiplier for MoveVelocity when sprinting
    [Property]
    var SprintModifier : Real = 2.0;
    
    //Force to be applied opposite of WorldUp when Jumping
    [Property]
    var JumpForce : Real = 3.0;
    
    [Property]
    var MaxGroundSpeed : Real = 25;
    
    //Maxium number of jumps before the player must land again
    [Property]
    var MaxJumpCount : Integer = 2;
    
    //Current number of jumps used since last on ground
    var JumpCount : Integer = 0;
    
    function Initialize(init : CogInitializer)
    {
        Zero.Connect(this.Space, Events.LogicUpdate, this.OnLogicUpdate);
        Zero.Connect(this.Owner, Events.CharMoveEvent, this.OnCharMoveEvent);
        Zero.Connect(this.Owner, Events.CharJumpEvent, this.OnCharJumpEvent);
    }

    function OnLogicUpdate(event : UpdateEvent)
    {
        //If the character is on a walkable surface clamp the current velocity to MaxGroundSpeed
        if(this.GroundDetection.IsOnGround || this.GroundDetection.IsPartiallyOnGround)
            this.RigidBody.Velocity = Math.Clamp(this.RigidBody.Velocity, -this.MaxGroundSpeed.XXX, this.MaxGroundSpeed.XXX);
    }

    function OnCharMoveEvent(event : CharMoveEvent)
    {
        //If the character is on a walkable surface
        if(this.GroundDetection.IsOnGround || this.GroundDetection.IsPartiallyOnGround)
        {
            //The movement force should be applied parallel to walkable surface.
            //To do this we rotate the surface normal by 90 or -90 degrees to get
            //a direction for the force.
            var dir = Real3();
            var angle = 0.0;
            if(event.MoveDir == -1)
            {
                angle = -Math.Pi/2;
                dir = Math.RotateVector(this.GroundDetection.GroundNormal, Real3(0,0,1), angle);
            }
            else if(event.MoveDir == 1)
            {
                angle = Math.Pi/2;
                dir = Math.RotateVector(this.GroundDetection.GroundNormal, Real3(0,0,1), angle);
            }
            var rat = Ray();
            rat.Start = this.Owner.Transform.Translation;
            rat.Direction = dir;
            this.DrawRay(rat, 5);
            
            var force = dir * this.MoveForce;
            
            if(event.SprintKeyDown)
                force *= this.SprintModifier;
            
            this.RigidBody.ApplyForce(force);
        }
    }

    function OnCharJumpEvent(event : CharJumpEvent)
    {
        //If the character IsOnGround this is the first jump
        if(this.GroundDetection.IsOnGround)
        {
            this.JumpCount = 1;
            this.Jump();
        }
        //If the character is not on ground but still has jumps left let it jump
        else if(this.JumpCount < this.MaxJumpCount)
        {
            this.JumpCount += 1;
            this.Jump();
        }
    }
    
    function Jump()
    {
        //Apply the jump force opposite the pull of gravity
        var dir = -this.GravityEffect.Direction;
        this.RigidBody.ApplyForce(dir * this.JumpForce);
    }
    
    function DrawRay(ray : Ray, len : Real)
    {
        var line = DebugLine();
        line.Start = ray.Start;
        line.End = ray.Start + (ray.Direction * len);
        line.Color = Real4(1,1,1,1);
        line.HeadSize = 1.0;
        line.OnTop = true;
        DebugDraw.Add(line);
    }
}
